<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: src/datastore.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: src/datastore.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import fetch from 'node-fetch';
import fs from 'fs';

/**
 * Client for GeoServer data stores
 *
 * @module DatastoreClient
 */
export default class DatastoreClient {
  /**
   * Creates a GeoServer REST DatastoreClient instance.
   *
   * @param {String} url The URL of the GeoServer REST API endpoint
   * @param {String} user The user for the GeoServer REST API
   * @param {String} password The password for the GeoServer REST API
   */
  constructor (url, user, password) {
    this.url = url.endsWith('/') ? url : url + '/';
    this.user = user;
    this.password = password;
  }

  /**
   * Get all DataStores in a workspace.
   *
   * @param {String} workspace The workspace to get DataStores for
   *
   * @returns {Object|Boolean} An object containing store details or 'false'
   */
  async getDataStores (workspace) {
    return this.getStores(workspace, 'datastores');
  }

  /**
   * Get all CoverageStores in a workspace.
   *
   * @param {String} workspace The workspace to get CoverageStores for
   *
   * @returns {Object|Boolean} An object containing store details or 'false'
   */
  async getCoverageStores (workspace) {
    return this.getStores(workspace, 'coveragestores');
  }

  /**
   * Get all WmsStores in a workspace.
   *
   * @param {String} workspace The workspace to get WmsStores for
   *
   * @returns {Object|Boolean} An object containing store details or 'false'
   */
  async getWmsStores (workspace) {
    return this.getStores(workspace, 'wmsstores');
  }

  /**
   * Get all WmtsStores in a workspace.
   *
   * @param {String} workspace The workspace to get WmtsStores for
   *
   * @returns {Object|Boolean} An object containing store details or 'false'
   */
  async getWmtsStores (workspace) {
    return this.getStores(workspace, 'wmtsstores');
  }

  /**
   * @private
   * Get information about various store types in a workspace.
   *
   * @param {String} workspace
   * @param {String} storeType
   *
   * @returns {Object|Boolean} An object containing store details or 'false'
   */
  async getStores (workspace, storeType) {
    try {
      const auth =
        Buffer.from(this.user + ':' + this.password).toString('base64');
      const response = await fetch(this.url + 'workspaces/' + workspace + '/' + storeType + '.json', {
        credentials: 'include',
        method: 'GET',
        headers: {
          Authorization: 'Basic ' + auth
        }
      });
      if (response.status === 200) {
        return await response.json();
      }
      console.warn(await response.text());
      return false;
    } catch (error) {
      return false;
    }
  }

  /**
   * Get specific DataStore by name in a workspace.
   *
   * @param {String} workspace The workspace to search DataStore in
   * @param {String} dataStore DataStore name
   *
   * @returns {Object|Boolean} An object containing store details or 'false'
   */
  async getDataStore (workspace, dataStore) {
    return this.getStore(workspace, dataStore, 'datastores');
  }

  /**
   * Get specific CoverageStore by name in a workspace.
   *
   * @param {String} workspace The workspace to search CoverageStore in
   * @param {String} covStore CoverageStore name
   *
   * @returns {Object|Boolean} An object containing store details or 'false'
   */
  async getCoverageStore (workspace, covStore) {
    return this.getStore(workspace, covStore, 'coveragestores');
  }

  /**
   * Get specific WmsStore by name in a workspace.
   *
   * @param {String} workspace The workspace to search WmsStore in
   * @param {String} wmsStore WmsStore name
   *
   * @returns {Object|Boolean} An object containing store details or 'false'
   */
  async getWmsStore (workspace, wmsStore) {
    return this.getStore(workspace, wmsStore, 'wmsstores');
  }

  /**
   * Get specific WmtsStore by name in a workspace.
   *
   * @param {String} workspace The workspace to search WmtsStore in
   * @param {String} wmtsStore WmtsStore name
   *
   * @returns {Object|Boolean} An object containing store details or 'false'
s  */
  async getWmtsStore (workspace, wmtsStore) {
    return this.getStore(workspace, wmtsStore, 'wmtsstores');
  }

  /**
   * @private
   * @param {String} workspace
   * @param {String} storeName
   * @param {String} storeType
   *
   * @returns {Object|Boolean} An object containing store details or 'false'
   */
  async getStore (workspace, storeName, storeType) {
    try {
      const auth =
        Buffer.from(this.user + ':' + this.password).toString('base64');
      const url = this.url + 'workspaces/' + workspace + '/' + storeType + '/' + storeName + '.json';
      const response = await fetch(url, {
        credentials: 'include',
        method: 'GET',
        headers: {
          Authorization: 'Basic ' + auth
        }
      });
      if (response.status === 200) {
        return await response.json();
      } else if (response.status === 404) {
        console.warn('No ' + storeType + ' with name "' + storeName + '" found');
        return false;
      } else {
        console.warn(await response.text());
        return false;
      }
    } catch (error) {
      return false;
    }
  }

  /**
   * Creates a GeoTIFF store from a file by path and publishes it as layer.
   * The GeoTIFF file has to be placed on the server, where your GeoServer
   * is running.
   *
   * @param {String} workspace The workspace to create GeoTIFF store in
   * @param {String} coverageStore The name of the new GeoTIFF store
   * @param {String} layerName The published name of the new layer
   * @param {String} layerTitle The published title of the new layer
   * @param {String} filePath The path to the GeoTIFF file on the server
   *
   * @returns {String|Boolean} The successful response text or 'false'
   */
  async createGeotiffFromFile (workspace, coverageStore, layerName, layerTitle, filePath) {
    try {
      const lyrTitle = layerTitle || layerName;
      const stats = fs.statSync(filePath);
      const fileSizeInBytes = stats.size;
      const readStream = fs.createReadStream(filePath);

      const auth =
        Buffer.from(this.user + ':' + this.password).toString('base64');
      let url = this.url + 'workspaces/' + workspace + '/coveragestores/' +
        coverageStore + '/file.geotiff';
      url += '?filename=' + lyrTitle + '&amp;coverageName=' + layerName;
      const response = await fetch(url, {
        credentials: 'include',
        method: 'PUT',
        headers: {
          Authorization: 'Basic ' + auth,
          'Content-Type': 'image/tiff',
          'Content-length': fileSizeInBytes
        },
        body: readStream
      });

      if (response.status === 201) {
        const responseText = await response.text();
        // TODO enforce JSON response or parse XML
        return responseText;
      } else {
        return false;
      }
    } catch (error) {
      return false;
    }
  }

  /**
   * Creates a PostGIS based data store.
   *
   * @param {String} workspace The WS to create the data store in
   * @param {String} namespaceUri The namespace URI of the workspace
   * @param {String} dataStore The data store name to be created
   * @param {String} pgHost The PostGIS DB host
   * @param {String} pgPort The PostGIS DB port
   * @param {String} pgUser The PostGIS DB user
   * @param {String} pgPassword The PostGIS DB password
   * @param {String} pgSchema The PostGIS DB schema
   * @param {String} pgDb The PostGIS DB name
   * @param {String} [exposePk] expose primary key, defaults to false
   *
   * @returns {Boolean} If the store could be created
   */
  async createPostgisStore (workspace, namespaceUri, dataStore, pgHost, pgPort, pgUser, pgPassword, pgSchema, pgDb, exposePk) {
    const body = {
      dataStore: {
        name: dataStore,
        type: 'PostGIS',
        enabled: true,
        workspace: {
          name: workspace
        },
        connectionParameters: {
          entry: [
            {
              '@key': 'dbtype',
              $: 'postgis'
            },
            {
              '@key': 'schema',
              $: pgSchema
            },
            {
              '@key': 'database',
              $: pgDb
            },
            {
              '@key': 'host',
              $: pgHost
            },
            {
              '@key': 'port',
              $: pgPort
            },
            {
              '@key': 'passwd',
              $: pgPassword
            },
            {
              '@key': 'namespace',
              $: namespaceUri
            },
            {
              '@key': 'user',
              $: pgUser
            },
            {
              '@key': 'Expose primary keys',
              $: exposePk || false
            }
          ]
        }
      }
    };

    const auth =
      Buffer.from(this.user + ':' + this.password).toString('base64');
    const url = this.url + 'workspaces/' + workspace + '/datastores';
    const response = await fetch(url, {
      credentials: 'include',
      method: 'POST',
      headers: {
        Authorization: 'Basic ' + auth,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(body)
    });

    if (response.status === 201) {
      return true;
    } else {
      console.warn(await response.text());
      return false;
    }
  }

  /**
   * Creates an ImageMosaic store from a zip archive with the 3 necessary files
   *   - datastore.properties
   *   - indexer.properties
   *   - timeregex.properties
   *
   * The zip archive has to be given as absolute path, so before it has to be
   * placed on the server, where your GeoServer is running.
   *
   * @param {String} workspace The WS to create the data store in
   * @param {String} dataStore The data store name
   * @param {String} zipArchivePath Aboslute path to zip archive with the 3 properties files
   *
   * @returns {String|Boolen} The response text or 'false'
   */
  async createImageMosaicStore (workspace, coverageStore, zipArchivePath) {
    try {
      const readStream = fs.createReadStream(zipArchivePath);
      const auth = Buffer.from(this.user + ':' + this.password).toString('base64');
      const url = this.url + 'workspaces/' + workspace + '/coveragestores/' + coverageStore + '/file.imagemosaic';
      const response = await fetch(url, {
        credentials: 'include',
        method: 'PUT',
        headers: {
          Authorization: 'Basic ' + auth,
          'Content-Type': 'application/zip'
        },
        body: readStream
      });

      if (response.status === 201) {
        return await response.text();
      } else {
        console.warn(await response.text());
        return false;
      }
    } catch (error) {
      console.log(error);
      return false;
    }
  };

  /**
   * Creates a WMS based data store.
   *
   * @param {String} workspace The WS to create the data store in
   * @param {String} dataStore The data store name
   * @param {String} wmsCapabilitiesUrl Base WMS capabilities URL
   *
   * @returns {Boolean} If store could be created
   */
  async createWmsStore (workspace, dataStore, wmsCapabilitiesUrl) {
    const body = {
      wmsStore: {
        name: dataStore,
        type: 'WMS',
        capabilitiesURL: wmsCapabilitiesUrl
      }
    };

    const auth =
      Buffer.from(this.user + ':' + this.password).toString('base64');
    const url = this.url + 'workspaces/' + workspace + '/wmsstores';
    const response = await fetch(url, {
      credentials: 'include',
      method: 'POST',
      headers: {
        Authorization: 'Basic ' + auth,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(body)
    });

    if (response.status === 201) {
      return true;
    } else {
      console.warn(await response.text());
      return false;
    }
  }

  /**
   * Creates a WFS based data store.
   *
   * @param {String} workspace The WS to create the data store in
   * @param {String} dataStore The data store name
   * @param {String} wfsCapabilitiesUrl WFS capabilities URL
   * @param {String} namespaceUrl URL of the GeoServer namespace
   *
   * @returns {Boolean} If store could be created
   */
  async createWfsStore (workspace, dataStore, wfsCapabilitiesUrl, namespaceUrl) {
    const body = {
      dataStore: {
        name: dataStore,
        type: 'Web Feature Server (NG)',
        connectionParameters: {
          entry: [
            {
              '@key': 'WFSDataStoreFactory:GET_CAPABILITIES_URL',
              $: wfsCapabilitiesUrl
            },
            {
              '@key': 'namespace',
              $: namespaceUrl
            }
          ]
        }
      }
    };

    const auth =
      Buffer.from(this.user + ':' + this.password).toString('base64');
    const url = this.url + 'workspaces/' + workspace + '/datastores';
    const response = await fetch(url, {
      credentials: 'include',
      method: 'POST',
      headers: {
        Authorization: 'Basic ' + auth,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(body)
    });

    if (response.status === 201) {
      return true;
    } else {
      console.warn(await response.text());
      return false;
    }
  }

  /**
   * Deletes a data store.
   *
   * @param {String} workspace The workspace where the data store is in
   * @param {String} coverageStore Name of data store to delete
   * @param {String} recurse Flag to enable recursive deletion
   *
   * @returns {Boolean} If the datastore could be deleted
   */
  async deleteDataStore (workspace, dataStore, recurse) {
    try {
      const auth =
        Buffer.from(this.user + ':' + this.password).toString('base64');
      let url = this.url + 'workspaces/' + workspace + '/datastores/' + dataStore;
      url += '?recurse=' + recurse;

      const response = await fetch(url, {
        credentials: 'include',
        method: 'DELETE',
        headers: {
          Authorization: 'Basic ' + auth
        }
      });

      if (response.status === 200) {
        return true;
      } else if (response.status === 401) {
        console.warn('Deletion failed. There might be dependant objects to ' +
          'this store. Delete them first or call this with "recurse=false"');
        console.warn(response.text());
        return false;
      } else {
        return false;
      }
    } catch (error) {
      return false;
    }
  }

  /**
   * Deletes a CoverageStore.
   *
   * @param {String} workspace The workspace where the CoverageStore is in
   * @param {String} coverageStore Name of CoverageStore to delete
   * @param {String} recurse Flag to enable recursive deletion
   *
   * @returns {Boolean} If the datastore could be deleted
   */
  async deleteCoverageStore (workspace, coverageStore, recurse) {
    try {
      const auth =
        Buffer.from(this.user + ':' + this.password).toString('base64');
      let url = this.url + 'workspaces/' + workspace + '/coveragestores/' + coverageStore;
      url += '?recurse=' + recurse;

      const response = await fetch(url, {
        credentials: 'include',
        method: 'DELETE',
        headers: {
          Authorization: 'Basic ' + auth
        }
      });

      if (response.status === 200) {
        return true;
      } else if (response.status === 401) {
        console.warn('Deletion failed. There might be dependant objects to ' +
          'this store. Delete them first or call this with "recurse=false"');
        console.warn(response.text());
        return false;
      } else {
        return false;
      }
    } catch (error) {
      return false;
    }
  }

  /**
   * Creates a GeoPackage store from a file placed in the geoserver_data dir.
   *
   * @param {String} workspace The WS to create the data store in
   * @param {String} dataStore The data store name
   * @param {String} gpkgPath Relative path to GeoPackage file within geoserver_data dir
   *
   * @returns {Boolean} If store could be created
   */
  async createGpkgStore (workspace, dataStore, gpkgPath) {
    const body = {
      dataStore: {
        name: dataStore,
        type: 'GeoPackage',
        connectionParameters: {
          entry: [
            {
              '@key': 'database',
              $: `file:${gpkgPath}`
            },
            {
              '@key': 'dbtype',
              $: 'geopkg'
            }
          ]
        }
      }
    };

    const auth =
      Buffer.from(this.user + ':' + this.password).toString('base64');
    const url = this.url + 'workspaces/' + workspace + '/datastores';
    const response = await fetch(url, {
      credentials: 'include',
      method: 'POST',
      headers: {
        Authorization: 'Basic ' + auth,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(body)
    });

    if (response.status === 201) {
      return true;
    } else {
      console.warn(await response.text());
      return false;
    }
  }
}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-DatastoreClient.html">DatastoreClient</a></li><li><a href="module-GeoServerRestClient.html">GeoServerRestClient</a></li><li><a href="module-ImageMosaicClient.html">ImageMosaicClient</a></li><li><a href="module-LayerClient.html">LayerClient</a></li><li><a href="module-NamespaceClient.html">NamespaceClient</a></li><li><a href="module-SecurityClient.html">SecurityClient</a></li><li><a href="module-SettingsClient.html">SettingsClient</a></li><li><a href="module-StyleClient.html">StyleClient</a></li><li><a href="module-WorkspaceClient.html">WorkspaceClient</a></li></ul><h3>Classes</h3><ul><li><a href="module-DatastoreClient.html">DatastoreClient</a></li><li><a href="module-GeoServerRestClient.html">GeoServerRestClient</a></li><li><a href="module-ImageMosaicClient.html">ImageMosaicClient</a></li><li><a href="module-LayerClient.html">LayerClient</a></li><li><a href="module-NamespaceClient.html">NamespaceClient</a></li><li><a href="module-SecurityClient.html">SecurityClient</a></li><li><a href="module-SettingsClient.html">SettingsClient</a></li><li><a href="module-StyleClient.html">StyleClient</a></li><li><a href="module-WorkspaceClient.html">WorkspaceClient</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.6</a> on Thu Aug 19 2021 06:38:01 GMT+0000 (Coordinated Universal Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
